[{"category":null,"content":"背景介绍 运行 INFINI Console 1.29.0 和 1.29.1 版本 的用户在 新初始化 平台后可能会遇到一个特定问题。如果后台的系统 Easysearch/Elasticsearch 集群（存储 Console 元数据的集群，通常名为 .infini_cluster 或类似名称）包含超过一个节点，Console UI 可能会错误地报告系统集群健康状态异常（例如，显示为不可用）。\n这是这些版本在特定条件下（新初始化的、多节点的系统集群）的一种显示或状态检测上的问题。底层的 Easysearch/Elasticsearch 集群本身的健康状态通常是绿色 (green) 的。\n","subcategory":null,"summary":"","tags":["INFINI Console","Easysearch/Elasticsearch"],"title":"修复 INFINI Console 1.29.0/1.29.1 版本中系统集群状态异常的问题","url":"https://blog.searchkit.tech/p/fix-infini-console-cluster-status/"},{"category":null,"content":"背景 我们公司最近计划将产品迁移到 Kubernetes 环境。 为了更好地管理和自动化我们的应用程序，我们决定使用 Kubernetes Operator。 本系列博客将记录我们学习和开发 Operator 的过程，希望能帮助更多的人入门 Operator 开发。\n目标读者 对 Kubernetes 有一定了解的开发人员和运维人员 希望使用 Operator 自动化管理应用程序的人员 对 Go 语言有基本了解的人员 准备工作 在开始之前，你需要准备以下环境：\nGo 语言环境 (\u0026gt;= 1.23): Operator 通常使用 Go 语言开发，你需要安装 Go 语言环境。 建议使用 Go 1.21 或更高版本。 可以从 https://go.dev/dl/ 下载安装包。 安装完成后，请配置好 GOPATH 和 PATH 环境变量。\nKubernetes 集群: 你需要一个可用的 Kubernetes 集群来部署和测试 Operator。 可以使用 Minikube、Kind 或其他的 Kubernetes 发行版。\nkubectl 命令行工具: kubectl 是 Kubernetes 的命令行工具，用于与 Kubernetes 集群交互。 请确保你已经安装并配置了 kubectl， 并且能够连接到你的 Kubernetes 集群。\nKubebuilder (\u0026gt;= 3.0): Kubebuilder 是一个用于快速构建 Kubernetes Operator 的框架。 使用 Kubebuilder 可以简化Operator 的开发流程，并生成一些必要的代码框架。 可以使用以下命令安装 Kubebuilder：\n1 2 3 cd $HOME/go/bin curl -L -o kubebuilder \u0026#34;https://go.kubebuilder.io/dl/latest/$(go env GOOS)/$(go env GOARCH)\u0026#34; chmod +x kubebuilder 请确保 $HOME/go/bin 目录在你的 PATH 环境变量中。 可以运行 kubebuilder version 命令来验证 Kubebuilder 是否安装成功。\nDocker (可选): 如果你需要构建 Operator 的 Docker 镜像，你需要安装 Docker。 我的环境是 MacOS(arm64) + Orbstack\n什么是 Operator？ 简单来说，Operator 是 Kubernetes 的扩展，它利用自定义资源（Custom Resources, CRs）来自动化管理应用程序。Operator 允许我们像管理 Kubernetes 内置资源一样管理复杂的应用程序，例如数据库、消息队列等。\n为什么选择 Operator？ Operator 提供了一种声明式的方式来管理应用程序的生命周期，包括部署、升级、备份、恢复等。它可以简化运维流程，提高自动化程度，并确保应用程序的状态符合预期。\n我们的第一个 Operator：Hello World 这个 Operator 将监听一个名为 HelloWorld 的自定义资源，并在 Kubernetes 中创建一个 Pod，该 Pod 运行一个简单的 \u0026ldquo;Hello World\u0026rdquo; 应用程序。\n1. 初始化 Kubebuilder 项目 首先，我们需要使用 Kubebuilder 创建一个新的项目。 在你的 GOPATH 目录下创建一个新的目录，例如 hello-world-operator，然后进入该目录，运行以下命令\n1 kubebuilder init --domain infini.cloud --repo github.com/infinilabs/hello-world-operator 这个命令会创建一个新的 Kubebuilder 项目，并生成一些必要的文件和目录。\n2. 创建自定义资源（Custom Resource Definition, CRD） 接下来，我们需要定义 HelloWorld 资源的结构。 运行以下命令\n1 kubebuilder create api --group example --version v1alpha1 --kind HelloWorld 这个命令会创建一个新的 API 定义，包括 api/v1alpha1/helloworld_types.go 和 controllers/helloworld_controller.go 两个文件。\n编辑 api/v1alpha1/helloworld_types.go 文件，修改 HelloWorldSpec 的定义，添加 name 和 message 字段：\n1 2 3 4 5 6 7 8 9 10 11 // HelloWorldSpec defines the desired state of HelloWorld type HelloWorldSpec struct { // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster // Important: Run \u0026#34;make\u0026#34; to regenerate code after modifying this file // Name is the name of the HelloWorld resource Name string `json:\u0026#34;name,omitempty\u0026#34;` // Message is the message to be printed by the pod Message string `json:\u0026#34;message,omitempty\u0026#34;` } 3. 实现 Reconcile 逻辑 编辑 controllers/helloworld_controller.go 文件，实现 Reconcile 函数， 创建一个 Pod，该 Pod 运行一个 busybox 镜像，并输出 HelloWorld 资源中定义的 message。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 package controllers import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; corev1 \u0026#34;k8s.io/api/core/v1\u0026#34; apierrors \u0026#34;k8s.io/apimachinery/pkg/api/errors\u0026#34; metav1 \u0026#34;k8s.io/apimachinery/pkg/apis/meta/v1\u0026#34; \u0026#34;k8s.io/apimachinery/pkg/runtime\u0026#34; ctrl \u0026#34;sigs.k8s.io/controller-runtime\u0026#34; \u0026#34;sigs.k8s.io/controller-runtime/pkg/client\u0026#34; \u0026#34;sigs.k8s.io/controller-runtime/pkg/log\u0026#34; examplev1alpha1 \u0026#34;github.com/infinilabs/hello-world-operator/api/v1alpha1\u0026#34; ) // HelloWorldReconciler reconciles a HelloWorld object type HelloWorldReconciler struct { client.Client Scheme *runtime.Scheme } //+kubebuilder:rbac:groups=example.com,resources=helloworlds,verbs=get;list;watch;create;update;patch;delete //+kubebuilder:rbac:groups=example.com,resources=helloworlds/status,verbs=get;update;patch //+kubebuilder:rbac:groups=example.com,resources=helloworlds/finalizers,verbs=update //+kubebuilder:rbac:groups=core,resources=pods,verbs=get;list;watch;create;update;patch;delete // Reconcile is part of the main kubernetes reconciliation loop which aims to // move the current state of the cluster closer to the desired state. // For more details, check Reconcile and its Result here: // - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.13.0/pkg/reconcile func (r *HelloWorldReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) { log := log.FromContext(ctx) // 1. Fetch the HelloWorld instance helloWorld := \u0026amp;examplev1alpha1.HelloWorld{} err := r.Get(ctx, req.NamespacedName, helloWorld) if err != nil { if apierrors.IsNotFound(err) { // Object not found, return. Created objects are automatically garbage collected. // For additional cleanup logic use finalizers. log.Info(\u0026#34;HelloWorld resource not found. Ignoring since object must be deleted\u0026#34;) return ctrl.Result{}, nil } // Error reading the object - requeue the request. log.Error(err, \u0026#34;Failed to get HelloWorld\u0026#34;) return ctrl.Result{}, err } // 2. Define the desired Pod pod := \u0026amp;corev1.Pod{ ObjectMeta: metav1.ObjectMeta{ Name: helloWorld.Name + \u0026#34;-pod\u0026#34;, Namespace: helloWorld.Namespace, Labels: map[string]string{ \u0026#34;app\u0026#34;: helloWorld.Name, }, }, Spec: corev1.PodSpec{ Containers: []corev1.Container{ { Name: \u0026#34;hello-world\u0026#34;, Image: \u0026#34;busybox\u0026#34;, Command: []string{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, fmt.Sprintf(\u0026#34;echo \u0026#39;%s\u0026#39; \u0026amp;\u0026amp; sleep 3600\u0026#34;, helloWorld.Spec.Message)}, }, }, }, } // 3. Set HelloWorld instance as the owner and controller if err := ctrl.SetControllerReference(helloWorld, pod, r.Scheme); err != nil { log.Error(err, \u0026#34;Failed to set controller reference\u0026#34;) return ctrl.Result{}, err } // 4. Check if the Pod already exists found := \u0026amp;corev1.Pod{} err = r.Get(ctx, client.ObjectKey{Name: pod.Name, Namespace: pod.Namespace}, found) if err != nil \u0026amp;\u0026amp; apierrors.IsNotFound(err) { log.Info(\u0026#34;Creating a new Pod\u0026#34;, \u0026#34;Pod.Namespace\u0026#34;, pod.Namespace, \u0026#34;Pod.Name\u0026#34;, pod.Name) err = r.Create(ctx, pod) if err != nil { log.Error(err, \u0026#34;Failed to create new Pod\u0026#34;, \u0026#34;Pod.Namespace\u0026#34;, pod.Namespace, \u0026#34;Pod.Name\u0026#34;, pod.Name) return ctrl.Result{}, err } // Pod created successfully - return and requeue return ctrl.Result{Requeue: true}, nil } else if err != nil { log.Error(err, \u0026#34;Failed to get Pod\u0026#34;) return ctrl.Result{}, err } // 5. Pod already exists - don\u0026#39;t requeue log.Info(\u0026#34;Skip reconcile: Pod already exists\u0026#34;, \u0026#34;Pod.Namespace\u0026#34;, found.Namespace, \u0026#34;Pod.Name\u0026#34;, found.Name) return ctrl.Result{}, nil } // SetupWithManager sets up the controller with the Manager. func (r *HelloWorldReconciler) SetupWithManager(mgr ctrl.Manager) error { return ctrl.NewControllerManagedBy(mgr). For(\u0026amp;examplev1alpha1.HelloWorld{}). Owns(\u0026amp;corev1.Pod{}). Complete(r) } 4. 安装 CRD 到 Kubernetes 集群 运行以下命令安装 CRD 到 Kubernetes 集群：\n1 make install 5. 运行 Operator 运行以下命令在本地运行 Operator：\n1 make run 6. 创建 HelloWorld 资源 创建一个名为 my-hello-world.yaml 的文件，内容如下：\n1 2 3 4 5 6 7 apiVersion: example.com/v1alpha1 kind: HelloWorld metadata: name: my-hello-world spec: name: my-hello-world message: \u0026#34;Hello World from Operator!\u0026#34; 使用 kubectl apply -f my-hello-world.yaml 创建资源。\n7. 验证 使用 kubectl get pods 命令查看是否创建了名为 my-hello-world-pod 的 Pod。 使用 kubectl logs my-hello-world-pod 查看 Pod 的日志，确认是否输出了 \u0026ldquo;Hello World from Operator!\u0026quot;。\n总结 恭喜你完成了第一个 Operator！ 虽然这个 Operator 非常简单，但它展示了 Operator 的基本原理：监听自定义资源，并根据资源的状态来管理 Kubernetes 资源。 在接下来的系列中，我们将深入探讨 Operator 的更多高级特性。\n敬请期待下一篇博客！\n","subcategory":null,"summary":"","tags":["Kubernetes","Operator"],"title":"Operator 开发入门系列（一）：Hello World!","url":"https://blog.searchkit.tech/p/operator/"},{"category":null,"content":" 互联网做得太棒了，以至于大多数人将它看作像太平洋这样的自然资源，而不是什么人工产物。上一次出现这种大规模且无差错的技术，你还记得是什么时候吗？\n—— 艾伦・凯 在接受 Dobb 博士杂志采访时说（2012 年）\n现今很多应用程序都是 数据密集型（data-intensive） 的，而非 计算密集型（compute-intensive） 的。因此 CPU 很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。\n数据密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应用程序都需要：\n存储数据，以便自己或其他应用程序之后能再次找到 （数据库，即 databases） 记住开销昂贵操作的结果，加快读取速度（缓存，即 caches） 允许用户按关键字搜索数据，或以各种方式对数据进行过滤（搜索索引，即 search indexes） 向其他进程发送消息，进行异步处理（流处理，即 stream processing） 定期处理累积的大批量数据（批处理，即 batch processing） 如果这些功能听上去平淡无奇，那是因为这些 数据系统（data system） 是非常成功的抽象：我们一直不假思索地使用它们并习以为常。绝大多数工程师不会幻想从零开始编写存储引擎，因为在开发应用时，数据库已经是足够完美的工具了。\n但现实没有这么简单。不同的应用有着不同的需求，因而数据库系统也是百花齐放，有着各式各样的特性。实现缓存有很多种手段，创建搜索索引也有好几种方法，诸如此类。因此在开发应用前，我们依然有必要先弄清楚最适合手头工作的工具和方法。而且当单个工具解决不了你的问题时，组合使用这些工具可能还是有些难度的。\n本书将是一趟关于数据系统原理、实践与应用的旅程，并讲述了设计数据密集型应用的方法。我们将探索不同工具之间的共性与特性，以及各自的实现原理。\n本章将从我们所要实现的基础目标开始：可靠、可伸缩、可维护的数据系统。我们将澄清这些词语的含义，概述考量这些目标的方法。并回顾一些后续章节所需的基础知识。在接下来的章节中我们将抽丝剥茧，研究设计数据密集型应用时可能遇到的设计决策。\n关于数据系统的思考 我们通常认为，数据库、消息队列、缓存等工具分属于几个差异显著的类别。虽然数据库和消息队列表面上有一些相似性 —— 它们都会存储一段时间的数据 —— 但它们有迥然不同的访问模式，这意味着迥异的性能特征和实现手段。\n那我们为什么要把这些东西放在 数据系统（data system） 的总称之下混为一谈呢？\n近些年来，出现了许多新的数据存储工具与数据处理工具。它们针对不同应用场景进行优化，因此不再适合生硬地归入传统类别【1】。类别之间的界限变得越来越模糊，例如：数据存储可以被当成消息队列用（Redis），消息队列则带有类似数据库的持久保证（Apache Kafka）。\n其次，越来越多的应用程序有着各种严格而广泛的要求，单个工具不足以满足所有的数据处理和存储需求。取而代之的是，总体工作被拆分成一系列能被单个工具高效完成的任务，并通过应用代码将它们缝合起来。\n例如，如果将缓存（应用管理的缓存层，Memcached 或同类产品）和全文搜索（全文搜索服务器，例如 Elasticsearch 或 Solr）功能从主数据库剥离出来，那么使缓存 / 索引与主数据库保持同步通常是应用代码的责任。图 1-1 给出了这种架构可能的样子（细节将在后面的章节中详细介绍）。\n","subcategory":null,"summary":"","tags":["Scale","Data"],"title":"可靠性、可伸缩性和可维护性","url":"https://blog.searchkit.tech/p/ddia/"}]